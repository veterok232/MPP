using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using TestGeneratorLib.Model;
using TestGeneratorLib.Model.Class;

namespace TestGeneratorLib.Block
{
    /// <summary>
    ///     Test generator
    /// </summary>
    public class TestGenerator
    {
        /// <summary>
        ///     Public modifier
        /// </summary>
        private static readonly SyntaxToken PublicModifier;

        /// <summary>
        ///     Private modifier
        /// </summary>
        private static readonly SyntaxToken PrivateModifier;

        /// <summary>
        ///     Static modifier
        /// </summary>
        private static readonly SyntaxToken StaticModifier;

        /// <summary>
        ///     Test class attribute ("TestFixture") 
        /// </summary>
        private static readonly AttributeSyntax ClassAttribute;

        /// <summary>
        ///     Setup method attribute ("SetUp") 
        /// </summary>
        private static readonly AttributeSyntax SetupAttribute;

        /// <summary>
        ///     Test method attribute ("Test") 
        /// </summary>
        private static readonly AttributeSyntax MethodAttribute;

        /// <summary>
        ///     Assert.Fail("autogenerated") expression 
        /// </summary>
        private static readonly ExpressionStatementSyntax FailExpression;

        /// <summary>
        ///     Test method return type (void)
        /// </summary>
        private static readonly TypeSyntax ReturnType;

        /// <summary>
        ///     Constructor
        /// </summary>
        static TestGenerator()
        {
            PublicModifier = Token(SyntaxKind.PublicKeyword);
            PrivateModifier = Token(SyntaxKind.PrivateKeyword);
            StaticModifier = Token(SyntaxKind.StaticKeyword);

            ClassAttribute = Attribute(ParseName("TestFixture"));
            SetupAttribute = Attribute(ParseName("SetUp"));
            MethodAttribute = Attribute(ParseName("Test"));

            FailExpression = CreateFailExpression();
            ReturnType = ParseTypeName("void");
        }

        /// <summary>
        ///     Generate Assert.Fail("autogenerated") expression 
        /// </summary>
        /// <returns>ExpressionStatementSyntax</returns>
        private static ExpressionStatementSyntax CreateFailExpression()
        {
            return ExpressionStatement(
                InvocationExpression(MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression, IdentifierName("Assert"), IdentifierName("Fail")
                ))
                .WithArgumentList(ArgumentList(
                    SingletonSeparatedList<ArgumentSyntax>(Argument(
                        LiteralExpression(SyntaxKind.StringLiteralExpression, Literal("autogenerated"))
                    ))
                ))
            );
        }

        /// <summary>
        ///     Main test generator method
        /// </summary>
        /// 
        /// <param name="fileData">File information</param>
        /// <returns>Dictionary<string, string></returns>
        public static Dictionary<string, string> GenerateTests(FileData fileData)
        {
            var testFiles = new Dictionary<string, string>();
            foreach (var classData in fileData.ClassesData)
            {
                var classNode = GenerateClass(classData);

                var testUnit = CompilationUnit()
                    .AddUsings(UsingDirective(ParseName("System")))
                    .AddUsings(UsingDirective(ParseName("System.Collections.Generic")))
                    .AddUsings(UsingDirective(ParseName("NUnit.Framework")))
                    .AddUsings(UsingDirective(ParseName("Moq")))
                    .AddMembers(classNode);

                testFiles.Add(classData.Name + "Test", testUnit.NormalizeWhitespace().ToFullString());
            }

            return testFiles;
        }

        /// <summary>
        ///     Generate class node
        /// </summary>
        /// 
        /// <param name="classData">Class information</param>
        /// <returns>ClassDeclarationSyntax</returns>
        private static ClassDeclarationSyntax GenerateClass(ClassData classData)
        {
            VariableDeclarationSyntax variable;
            var fields = new List<FieldDeclarationSyntax>();

            // Generate intefaces
            ConstructorData constructor = null;
            if (classData.ConstructorsData.Count > 0)
            {
                constructor = FindLargestConstructor(classData.ConstructorsData);
                var interfaces = HandleCustomType(constructor.Parameters);

                foreach (var custom in interfaces)
                {
                    variable = GenerateVariable($"Mock<{custom.Value}>", custom.Key);
                    fields.Add(GenerateField(variable));
                }
            }

            // Generate class properties
            variable = GenerateVariable(classData.Name, HandleVariable(classData.Name));
            fields.Add(GenerateField(variable));

            // Generate methods
            var methods = new List<MethodDeclarationSyntax>();
            methods.Add(GenerateSetUpMethod(constructor, classData.Name));

            foreach (var methodInfo in classData.MethodsData)
            {
                methods.Add(GenerateMethod(methodInfo, classData.Name));
            }

            return ClassDeclaration(classData.Name + "Test")
                .AddMembers(fields.ToArray())
                .AddMembers(methods.ToArray())
                .AddAttributeLists(AttributeList(AttributeList().Attributes.Add(ClassAttribute)));
        }

        /// <summary>
        ///     Find cinstructor with maximum parameters count
        /// </summary>
        /// 
        /// <param name="constructorsData">Constructors information</param>
        /// <returns>ConstructorData</returns>
        private static ConstructorData FindLargestConstructor(List<ConstructorData> constructorsData)
        {
            var constructor = constructorsData[0];
            foreach (var temp in constructorsData)
            {
                if (constructor.Parameters.Count < temp.Parameters.Count)
                {
                    constructor = temp;
                }
            }
            return constructor;
        }

        /// <summary>
        ///     Format base type
        /// </summary>
        /// 
        /// <param name="parameters">Parameters</param>
        /// <returns>Dictionary<string, string></returns>
        private static Dictionary<string, string> HandleBaseType(Dictionary<string, string> parameters)
        {
            var types = new Dictionary<string, string>();
            foreach (var parameter in parameters)
            {
                // If not an interface
                if (parameter.Value[0] != 'I')
                {
                    types.Add(parameter.Key, parameter.Value);
                }
            }

            return types;
        }

        /// <summary>
        ///     Format custom type
        /// </summary>
        /// 
        /// <param name="parameters">Parameters</param>
        /// <returns>Dictionary<string, string></returns>
        private static Dictionary<string, string> HandleCustomType(Dictionary<string, string> parameters)
        {
            var types = new Dictionary<string, string>();
            foreach (var parameter in parameters)
            {
                // If an interface
                if (parameter.Value[0] == 'I')
                {
                    types.Add(parameter.Key, parameter.Value);
                }
            }
            return types;
        }

        /// <summary>
        ///     Create variable name from type
        /// </summary>
        /// 
        /// <param name="type">Type name</param>
        /// <returns>string</returns>
        private static string HandleVariable(string type)
        {
            return type[0].ToString().ToLower() + type.Remove(0, 1);
        }

        /// <summary>
        ///     Generate variable with type
        /// </summary>
        /// 
        /// <param name="type">Type name</param>
        /// <param name="name">Variable name</param>
        /// <returns>VariableDeclarationSyntax</returns>
        private static VariableDeclarationSyntax GenerateVariable(string type, string name)
        {
            return VariableDeclaration(ParseTypeName(type)).AddVariables(VariableDeclarator(name));
        }

        /// <summary>
        ///     Generate field node
        /// </summary>
        /// 
        /// <param name="variable">Variable</param>
        /// <returns>FieldDeclarationSyntax</returns>
        private static FieldDeclarationSyntax GenerateField(VariableDeclarationSyntax variable)
        {
            return FieldDeclaration(variable).AddModifiers(Token(SyntaxKind.PrivateKeyword));
        }

        /// <summary>
        ///     Generate setup method
        /// </summary>
        /// 
        /// <param name="constructorData">Constructor data</param>
        /// <param name="className">Class name</param>
        /// <returns>MethodDeclarationSyntax</returns>
        private static MethodDeclarationSyntax GenerateSetUpMethod(ConstructorData constructorData, string className)
        {
            List<StatementSyntax> body = new List<StatementSyntax>();
            if (constructorData != null)
            {
                var baseTypeVariables = HandleBaseType(constructorData.Parameters);
                foreach (var var in baseTypeVariables)
                {
                    body.Add(GenerateBasesTypesAssignStatement(var.Key, var.Value));
                }
                var customVariables = HandleCustomType(constructorData.Parameters);
                foreach (var var in customVariables)
                {
                    body.Add(GenerateCustomsTypesAssignStatement(var.Key, $"Mock<{var.Value}>", ""));
                }
            }

            body.Add(GenerateCustomsTypesAssignStatement(
                HandleVariable(className), className, constructorData != null ? 
                    ConvertParametersToStringRepresentation(constructorData.Parameters) : ""
                )
            );

            return MethodDeclaration(ReturnType, "SetUp")
                .AddModifiers(PublicModifier)
                .AddAttributeLists(AttributeList(AttributeList().Attributes.Add(SetupAttribute)))
                .WithBody(SyntaxFactory.Block(body));
        }

        /// <summary>
        ///     Generate method node
        /// </summary>
        /// 
        /// <param name="methodData">Method information</param>
        /// <param name="classVariable">Variable</param>
        /// <returns>MethodDeclarationSyntax</returns>
        private static MethodDeclarationSyntax GenerateMethod(MethodData methodData, string classVariable)
        {
            List<StatementSyntax> body = new List<StatementSyntax>();

            GenerateArrangePart(body, methodData.Parameters);
            GenerateActPart(body, methodData, classVariable);
            
            if (methodData.ReturnType != "void")
            {
                GenerateAssertPart(body, methodData.ReturnType);
            }
            body.Add(FailExpression);

            return MethodDeclaration(ReturnType, methodData.Name)
                .AddModifiers(PublicModifier)
                .AddAttributeLists(AttributeList(AttributeList().Attributes.Add(MethodAttribute)))
                .WithBody(SyntaxFactory.Block(body));
        }

        /// <summary>
        ///     Get base type node
        /// </summary>
        /// 
        /// <param name="name">Name</param>
        /// <param name="type">Type</param>
        /// <returns>StatementSyntax</returns>
        private static StatementSyntax GenerateBasesTypesAssignStatement(string name, string type)
        {
            return ParseStatement(string.Format("var {0} = default({1});", name, type));
        }

        /// <summary>
        ///     Get custom type node
        /// </summary>
        /// 
        /// <param name="name">Name</param>
        /// <param name="constructorName">Constructor name</param>
        /// <param name="invokeArgs">Arguments</param>
        /// <returns>StatementSyntax</returns>
        private static StatementSyntax GenerateCustomsTypesAssignStatement(string name, string constructorName, string invokeArgs = "")
        {
            return ParseStatement(string.Format("{0} = new {1}{2};", name, constructorName, $"({invokeArgs})"));
        }

        /// <summary>
        ///     Get string representation
        /// </summary>
        /// 
        /// <param name="parameters">Parameters</param>
        /// <returns>string</returns>
        private static string ConvertParametersToStringRepresentation(Dictionary<string, string> parameters)
        {
            var s = "";
            foreach (var pair in parameters)
            {
                s += pair.Value[0] == 'I' ? $"{pair.Key}.Object" : $"{pair.Key}";
                s += ", ";
            }

            return s.Length > 0 ? s.Remove(s.Length - 2, 2) : "";
        }

        /// <summary>
        ///     Get function call node
        /// </summary>
        /// 
        /// <param name="varName">Variables</param>
        /// <param name="funcName">Name</param>
        /// <param name="invokeArgs">Argument</param>
        /// <returns>StatementSyntax</returns>
        private static StatementSyntax GenerateFunctionCall(string varName, string funcName, string invokeArgs = "")
        {
            return ParseStatement(string.Format("var {0} = {1}{2};", varName, funcName, $"({invokeArgs})"));
        }

        /// <summary>
        ///     Get void function call node
        /// </summary>
        /// 
        /// <param name="funcName">Name</param>
        /// <param name="invokeArgs">Arguments</param>
        /// <returns>StatementSyntax</returns>
        private static StatementSyntax GenerateVoidFunctionCall(string funcName, string invokeArgs = "")
        {
            return ParseStatement(string.Format("{0}{1};", funcName, $"({invokeArgs})"));
        }

        /// <summary>
        ///     Get expression
        /// </summary>
        /// 
        /// <param name="firstCall">Method call 1</param>
        /// <param name="secondCall">Method call 2</param>
        /// <returns>InvocationExpressionSyntax</returns>
        private static InvocationExpressionSyntax GenerateExpression(string firstCall, string secondCall)
        {
            return InvocationExpression(MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression, IdentifierName(firstCall), IdentifierName(secondCall)
            ));
        }

        /// <summary>
        ///     Arrange section
        /// </summary>
        /// 
        /// <param name="body">Body</param>
        /// <param name="parameters">Parameters</param>
        private static void GenerateArrangePart(List<StatementSyntax> body, Dictionary<string, string> parameters)
        {
            var baseTypeVars = HandleBaseType(parameters);
            foreach (var var in baseTypeVars)
            {
                body.Add(GenerateBasesTypesAssignStatement(var.Key, var.Value));
            }
        }

        /// <summary>
        ///     Get act section
        /// </summary>
        /// 
        /// <param name="body">Body</param>
        /// <param name="methodData">Method information</param>
        /// <param name="classVariable">Variable</param>
        private static void GenerateActPart(List<StatementSyntax> body, MethodData methodData, string classVariable)
        {
            if (methodData.ReturnType != "void")
            {
                body.Add(GenerateFunctionCall("actual", HandleVariable(classVariable) + "." + methodData.Name, 
                    ConvertParametersToStringRepresentation(methodData.Parameters)));
            }
            else
            {
                body.Add(GenerateVoidFunctionCall(HandleVariable(classVariable) + "." + methodData.Name, 
                    ConvertParametersToStringRepresentation(methodData.Parameters)));
            }
        }

        /// <summary>
        ///     Assert section
        /// </summary>
        /// 
        /// <param name="body">Body</param>
        /// <param name="returnType">Return type</param>
        private static void GenerateAssertPart(List<StatementSyntax> body, string returnType)
        {
            body.Add(GenerateBasesTypesAssignStatement("expected", returnType));

            // Get check Assert.That(actual, Is.EqualTo(expected))
            var invocationExpression = GenerateExpression("Assert", "That");
            var secondPart = GenerateExpression("Is", "EqualTo")
                .WithArgumentList(ArgumentList(SeparatedList<ArgumentSyntax>(
                    new SyntaxNodeOrToken[] { 
                        Argument(IdentifierName("expected"))
                    }
                )));
            var argList = ArgumentList(SeparatedList<ArgumentSyntax>(
                    new SyntaxNodeOrToken[] {
                        Argument(IdentifierName("actual")),
                        Token(SyntaxKind.CommaToken),
                        Argument(IdentifierName(secondPart.ToString()))
                    }
                ));
            var s = ExpressionStatement(invocationExpression.WithArgumentList(argList));
            body.Add(s);
        }
    }
}
